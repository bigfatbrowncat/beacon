diff --git a/tools/sk_app/win/GLWindowContext_win.cpp b/tools/sk_app/win/GLWindowContext_win.cpp
index 32c47b4f58..594a82942f 100644
--- a/tools/sk_app/win/GLWindowContext_win.cpp
+++ b/tools/sk_app/win/GLWindowContext_win.cpp
@@ -11,11 +11,13 @@
 #include "tools/sk_app/GLWindowContext.h"
 #include "tools/sk_app/win/WindowContextFactory_win.h"
 
-#include <Windows.h>
 #include <GL/gl.h>
+#include <Windows.h>
+
+#include <iostream>
 
-using sk_app::GLWindowContext;
 using sk_app::DisplayParams;
+using sk_app::GLWindowContext;
 
 #if defined(_M_ARM64)
 
@@ -43,56 +45,68 @@ protected:
     void onDestroyContext() override;
 
 private:
-    HWND              fHWND;
-    HGLRC             fHGLRC;
+    HWND fHWND;
+    HGLRC fHGLRC;
 
     typedef GLWindowContext INHERITED;
 };
 
 GLWindowContext_win::GLWindowContext_win(HWND wnd, const DisplayParams& params)
-    : INHERITED(params)
-    , fHWND(wnd)
-    , fHGLRC(NULL) {
-
+        : INHERITED(params), fHWND(wnd), fHGLRC(NULL) {
     // any config code here (particularly for msaa)?
 
     this->initializeContext();
 }
 
-GLWindowContext_win::~GLWindowContext_win() {
-    this->destroyContext();
-}
+GLWindowContext_win::~GLWindowContext_win() { this->destroyContext(); }
 
 sk_sp<const GrGLInterface> GLWindowContext_win::onInitializeContext() {
     HDC dc = GetDC(fHWND);
-
-    fHGLRC = SkCreateWGLContext(dc, fDisplayParams.fMSAASampleCount, false /* deepColor */,
-                                kGLPreferCompatibilityProfile_SkWGLContextRequest);
-    if (NULL == fHGLRC) {
+    if (dc == NULL) {
+        std::cout << "GLWindowContext_win::onInitializeContext: dc = NULL" << std::endl;
         return nullptr;
     }
 
-    SkWGLExtensions extensions;
-    if (extensions.hasExtension(dc, "WGL_EXT_swap_control")) {
-        extensions.swapInterval(fDisplayParams.fDisableVsync ? 0 : 1);
-    }
+    if (NULL == fHGLRC) {
+        std::cout << "GLWindowContext_win::onInitializeContext: initializing the context" << std::endl;
+        fHGLRC = SkCreateWGLContext(dc, fDisplayParams.fMSAASampleCount, false /* deepColor */,
+                                    kGLPreferCompatibilityProfile_SkWGLContextRequest);
+        if (NULL == fHGLRC) {
+            std::cout << "GLWindowContext_win::onInitializeContext: SkCreateWGLContext returns NULL"
+                      << std::endl;
+            return nullptr;
+        }
 
-    // Look to see if RenderDoc is attached. If so, re-create the context with a core profile
-    if (wglMakeCurrent(dc, fHGLRC)) {
-        auto interface = GrGLMakeNativeInterface();
-        bool renderDocAttached = interface->hasExtension("GL_EXT_debug_tool");
-        interface.reset(nullptr);
-        if (renderDocAttached) {
-            wglDeleteContext(fHGLRC);
-            fHGLRC = SkCreateWGLContext(dc, fDisplayParams.fMSAASampleCount, false /* deepColor */,
-                                        kGLPreferCoreProfile_SkWGLContextRequest);
-            if (NULL == fHGLRC) {
-                return nullptr;
+        SkWGLExtensions extensions;
+        if (extensions.hasExtension(dc, "WGL_EXT_swap_control")) {
+            extensions.swapInterval(fDisplayParams.fDisableVsync ? 0 : 1);
+        }
+
+        // Look to see if RenderDoc is attached. If so, re-create the context with a core profile
+        if (wglMakeCurrent(dc, fHGLRC)) {
+            auto interface = GrGLMakeNativeInterface();
+            bool renderDocAttached = interface->hasExtension("GL_EXT_debug_tool");
+            interface.reset(nullptr);
+            if (renderDocAttached) {
+                wglDeleteContext(fHGLRC);
+                fHGLRC = SkCreateWGLContext(dc, fDisplayParams.fMSAASampleCount,
+                                            false /* deepColor */,
+                                            kGLPreferCoreProfile_SkWGLContextRequest);
+                if (NULL == fHGLRC) {
+                    std::cout << "GLWindowContext_win::onInitializeContext: SkCreateWGLContext "
+                                 "returns NULL (2)" << std::endl;
+                    return nullptr;
+                }
             }
+        } else {
+            std::cout << "GLWindowContext_win::onInitializeContext: wglMakeCurrent returns NULL"
+                      << std::endl;
         }
     }
 
     if (wglMakeCurrent(dc, fHGLRC)) {
+        SkWGLExtensions extensions;
+
         glClearStencil(0);
         glClearColor(0, 0, 0, 0);
         glStencilMask(0xffffffff);
@@ -107,12 +121,8 @@ sk_sp<const GrGLInterface> GLWindowContext_win::onInitializeContext() {
         // Get sample count if the MSAA WGL extension is present
         if (extensions.hasExtension(dc, "WGL_ARB_multisample")) {
             static const int kSampleCountAttr = SK_WGL_SAMPLES;
-            extensions.getPixelFormatAttribiv(dc,
-                                              pixelFormat,
-                                              0,
-                                              1,
-                                              &kSampleCountAttr,
-                                              &fSampleCount);
+            extensions.getPixelFormatAttribiv(
+                    dc, pixelFormat, 0, 1, &kSampleCountAttr, &fSampleCount);
             fSampleCount = SkTMax(fSampleCount, 1);
         } else {
             fSampleCount = 1;
@@ -122,25 +132,32 @@ sk_sp<const GrGLInterface> GLWindowContext_win::onInitializeContext() {
         GetClientRect(fHWND, &rect);
         fWidth = rect.right - rect.left;
         fHeight = rect.bottom - rect.top;
-        glViewport(0, 0, fWidth, fHeight);
+
+        // Instead of creating a viewport with our window size,
+        // we are creating the biggest possible one.
+        // Changing the viweport size takes time that makes
+        // window resizing slow
+        int vsWidth = GetSystemMetrics(SM_CXVIRTUALSCREEN);
+        int vsHeight = GetSystemMetrics(SM_CYVIRTUALSCREEN);
+        glViewport(0, 0, vsWidth, vsHeight);
+    } else {
+        std::cout << "GLWindowContext_win::onInitializeContext: wglMakeCurrent returns NULL (2)"
+                  << std::endl;
     }
     return GrGLMakeNativeInterface();
 }
 
-
 void GLWindowContext_win::onDestroyContext() {
     wglDeleteContext(fHGLRC);
     fHGLRC = NULL;
 }
 
-
 void GLWindowContext_win::onSwapBuffers() {
     HDC dc = GetDC((HWND)fHWND);
     SwapBuffers(dc);
     ReleaseDC((HWND)fHWND, dc);
 }
 
-
 }  // anonymous namespace
 
 namespace sk_app {
